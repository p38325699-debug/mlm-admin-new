"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.imageHash = void 0;
const fs_1 = __importDefault(require("fs"));
const buffer_1 = require("buffer");
const file_type_1 = require("file-type");
const jpeg_js_1 = __importDefault(require("jpeg-js"));
const pngjs_1 = require("pngjs");
const url_1 = require("url");
const webp_1 = __importDefault(require("@cwasm/webp"));
const block_hash_1 = __importDefault(require("./block-hash"));
const processPNG = (data, bits, method, cb) => {
    try {
        const png = pngjs_1.PNG.sync.read(data);
        const res = (0, block_hash_1.default)(png, bits, method ? 2 : 1);
        cb(null, res);
    }
    catch (e) {
        cb(e);
    }
};
const processJPG = (data, bits, method, cb) => {
    try {
        const decoded = jpeg_js_1.default.decode(data);
        const res = (0, block_hash_1.default)(decoded, bits, method ? 2 : 1);
        cb(null, res);
    }
    catch (e) {
        cb(e);
    }
};
const processWebp = (data, bits, method, cb) => {
    try {
        const decoded = webp_1.default.decode(data);
        const res = (0, block_hash_1.default)(decoded, bits, method ? 2 : 1);
        cb(null, res);
    }
    catch (e) {
        cb(e);
    }
};
const isUrlRequestObject = (obj) => {
    const casted = obj;
    return casted.url && casted.url.length > 0;
};
const isBufferObject = (obj) => {
    const casted = obj;
    return buffer_1.Buffer.isBuffer(casted.data)
        || (buffer_1.Buffer.isBuffer(casted.data) && (casted.ext && casted.ext.length > 0));
};
// eslint-disable-next-line
const imageHash = (oldSrc, bits, method, cb) => {
    const src = oldSrc;
    const getFileType = (data) => __awaiter(void 0, void 0, void 0, function* () {
        if (typeof src !== 'string' && isBufferObject(src) && src.ext) {
            return {
                mime: src.ext,
            };
        }
        if (buffer_1.Buffer.isBuffer(data)) {
            return (0, file_type_1.fileTypeFromBuffer)(data);
        }
        if (typeof src === 'string') {
            return (0, file_type_1.fileTypeFromFile)(src);
        }
        return '';
    });
    const checkFileType = (name, data) => {
        getFileType(data).then((type) => {
            // what is the image type
            if (!type) {
                cb(new Error('Mime type not found'));
                return;
            }
            if (name && name.lastIndexOf('.') > 0) {
                const ext = name
                    .split('.')
                    .pop()
                    .toLowerCase();
                if (ext === 'png' && type.mime === 'image/png') {
                    processPNG(data, bits, method, cb);
                }
                else if ((ext === 'jpg' || ext === 'jpeg') && type.mime === 'image/jpeg') {
                    processJPG(data, bits, method, cb);
                }
                else if (ext === 'webp' && type.mime === 'image/webp') {
                    processWebp(data, bits, method, cb);
                }
                else {
                    cb(new Error(`Unrecognized file extension, mime type or mismatch, ext: ${ext} / mime: ${type.mime}`));
                }
            }
            else {
                if (process.env.verbose)
                    console.warn('No file extension found, attempting mime typing.');
                if (type.mime === 'image/png') {
                    processPNG(data, bits, method, cb);
                }
                else if (type.mime === 'image/jpeg') {
                    processJPG(data, bits, method, cb);
                }
                else if (type.mime === 'image/webp') {
                    processWebp(data, bits, method, cb);
                }
                else {
                    cb(new Error(`Unrecognized mime type: ${type.mime}`));
                }
            }
        }).catch((err) => {
            cb(err);
        });
    };
    const fetchRemoteImage = (remoteSrc) => __awaiter(void 0, void 0, void 0, function* () {
        if (fetch && typeof fetch !== 'function') {
            cb(new Error('Global fetch API is not available. Node.js 18+ is required.'));
            return;
        }
        const requestUrl = typeof remoteSrc === 'string' ? remoteSrc : remoteSrc.url;
        if (!requestUrl) {
            cb(new Error('No URL provided for remote image.'));
            return;
        }
        let init;
        if (typeof remoteSrc !== 'string') {
            init = Object.assign({}, remoteSrc);
            delete init.url;
            delete init.encoding;
        }
        try {
            const response = yield fetch(requestUrl, init);
            if (!response || !response.ok) {
                const status = response ? `${response.status} ${response.statusText}` : 'Unknown status';
                throw new Error(`Failed to fetch image. HTTP status: ${status}`);
            }
            const arrayBuffer = yield response.arrayBuffer();
            const buffer = buffer_1.Buffer.from(arrayBuffer);
            let pathname = '';
            try {
                const url = new url_1.URL(response.url || requestUrl);
                pathname = url.pathname;
            }
            catch (err) {
                pathname = '';
            }
            checkFileType(pathname, buffer);
        }
        catch (error) {
            cb(error);
        }
    });
    const handleReadFile = (err, res) => {
        if (err) {
            cb(new Error(err));
            return;
        }
        checkFileType(src, res);
    };
    // check source
    // is source assigned
    if (src === undefined) {
        cb(new Error('No image source provided'));
        return;
    }
    // is src url or file
    if (typeof src === 'string' && (src.indexOf('http') === 0 || src.indexOf('https') === 0)) {
        // url
        fetchRemoteImage(src);
    }
    else if (typeof src !== 'string' && isBufferObject(src)) {
        // image buffers
        checkFileType(src.name, src.data);
    }
    else if (typeof src !== 'string' && isUrlRequestObject(src)) {
        // Request Object
        fetchRemoteImage(src);
    }
    else {
        // file
        fs_1.default.readFile(src, handleReadFile);
    }
};
exports.imageHash = imageHash;
//# sourceMappingURL=index.js.map